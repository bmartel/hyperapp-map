{"version":3,"sources":["dist/hyperappmap.js"],"names":["hyperappmap","MEMO","isFunc","x","mapObj","o","f","Object","entries","map","k","v","reduce","shallowEqual","a","b","keys","length","eq","isAction","Array","isArray","mapEffect","M","fn","props","mapVNode","vnode","key","val","startsWith","children","child","extract","merge","actionMap","action","state","data","resolve","slice","makeActionMap","sub","result","filter","p","r","_","push","mapSub"],"mappings":"AAAA,IAAIA,YAAe,WACf,MAAMC,EAAO,GAEPC,EAASC,GAAkB,mBAANA,EAcrBC,EAAS,CAACC,EAAGC,IACfC,OAAOC,QAAQH,GACVI,IAAI,EAAEC,EAAGC,KAAO,CAACD,EAAGJ,EAAEI,EAAGC,KACzBC,OAAO,CAACP,GAAIK,EAAGC,MAASN,EAAEK,GAAKC,EAAIN,GAAI,IAE1CQ,EAAe,CAACC,EAAGC,EAAGC,EAAOT,OAAOS,KAAKF,KAC3CE,EAAKC,SAAWV,OAAOS,KAAKD,GAAGE,QAEzBD,EAAKJ,OAAO,CAACM,EAAIR,IAAMQ,GAAMJ,EAAEJ,KAAOK,EAAEL,IAAI,GAEhDS,EAAWhB,GAAKD,EAAOC,IAAOiB,MAAMC,QAAQlB,IAAMgB,EAAShB,EAAE,IAE7DmB,EAAY,CAACC,GAAIC,EAAIC,KAAW,CAClCD,EACApB,EAAOqB,EAAO,CAACf,EAAGC,IAAOQ,EAASR,GAAKY,EAAEZ,GAAKA,IAsB5Ce,EAAW,CAACH,EAAGI,KAAU,IACxBA,EACHF,MAAOrB,EAAOuB,EAAMF,MAAO,CAACG,EAAKC,IAC7BD,EAAIE,WAAW,MAAQP,EAAEM,GAAOA,GAEpCE,SAAUJ,EAAMI,SAAStB,IAAIuB,GAASN,EAASH,EAAGS,MAUtD,MAPY,CAACC,EAASC,EAAO/B,EAAGoB,EA3BV,EAACU,EAASC,KAC5B,SAASC,EAAUC,GACf,MAAO,CAACC,EAAOC,KACX,SAAUC,EAAQpC,EAAGkC,EAAOC,GACxB,OAAOpC,EAAOC,GACRoC,EAAQpC,EAAE8B,EAAQI,GAAQC,GAAOD,GAChCjB,MAAMC,QAAQlB,GAEdgB,EAAShB,EAAE,IAKZD,EAAOC,EAAE,IACToC,EAAQpC,EAAE,GAAIkC,EAAOlC,EAAE,GAAGmC,IAC1BC,EAAQpC,EAAE,GAAIkC,EAAOlC,EAAE,IANvB,CACI+B,EAAMG,EAAOlC,EAAE,OACZA,EAAEqC,MAAM,GAAG/B,IAAIH,GAAKgB,EAAUa,EAAW7B,KAJhD4B,EAAMG,EAAOlC,IAJvB,CAaGiC,EAAQC,EAAOC,KAWMG,CAAcR,EAASC,KACvDhC,EAAOC,GACDoB,EAAEpB,GACFiB,MAAMC,QAAQlB,GACdA,EAAEM,IAAIiC,GA5DD,EAACnB,GAAIC,EAAIC,MACpB,IAAIkB,EAAS1C,EAAK2C,OACd,EAAEtC,EAAGuC,EAAGC,KAAOxC,IAAMkB,GAAMX,EAAaY,EAAOoB,IACjDjC,OAAO,CAACmC,GAAIzC,EAAGuC,EAAGC,KAAOA,EAAG,MAM9B,OAJKH,IACDA,EAASrB,EAAUC,EAAG,CAACC,EAAIC,IAC3BxB,EAAK+C,KAAK,CAACxB,EAAIC,EAAOkB,KAEnBA,GAmDYM,CAAO1B,EAAGmB,IACvBhB,EAASH,EAAGpB,GAlER","sourcesContent":["var hyperappmap = (function () {\n    const MEMO = [];\n\n    const isFunc = x => typeof x === 'function';\n\n    const mapSub = (M, [fn, props]) => {\n        let result = MEMO.filter(\n            ([f, p, r]) => f === fn && shallowEqual(props, p)\n        ).reduce((_, [f, p, r]) => r, null);\n\n        if (!result) {\n            result = mapEffect(M, [fn, props]);\n            MEMO.push([fn, props, result]);\n        }\n        return result\n    };\n\n    const mapObj = (o, f) =>\n        Object.entries(o)\n            .map(([k, v]) => [k, f(k, v)])\n            .reduce((o, [k, v]) => ((o[k] = v), o), {});\n\n    const shallowEqual = (a, b, keys = Object.keys(a)) =>\n        keys.length !== Object.keys(b).length\n            ? false\n            : keys.reduce((eq, k) => eq && a[k] === b[k], true);\n\n    const isAction = x => isFunc(x) || (Array.isArray(x) && isAction(x[0]));\n\n    const mapEffect = (M, [fn, props]) => [\n        fn,\n        mapObj(props, (k, v) => (isAction(v) ? M(v) : v)),\n    ];\n\n    const makeActionMap = (extract, merge) =>\n        function actionMap(action) {\n            return (state, data) =>\n                (function resolve(x, state, data) {\n                    return isFunc(x)\n                        ? resolve(x(extract(state), data), state)\n                        : !Array.isArray(x)\n                        ? merge(state, x)\n                        : !isAction(x[0])\n                        ? [\n                              merge(state, x[0]),\n                              ...x.slice(1).map(f => mapEffect(actionMap, f)),\n                          ]\n                        : isFunc(x[1])\n                        ? resolve(x[0], state, x[1](data))\n                        : resolve(x[0], state, x[1])\n                })(action, state, data)\n        };\n\n    const mapVNode = (M, vnode) => ({\n        ...vnode,\n        props: mapObj(vnode.props, (key, val) =>\n            key.startsWith('on') ? M(val) : val\n        ),\n        children: vnode.children.map(child => mapVNode(M, child)),\n    });\n\n    var index = (extract, merge, x, M = makeActionMap(extract, merge)) =>\n        isFunc(x)\n            ? M(x)\n            : Array.isArray(x)\n            ? x.map(sub => mapSub(M, sub))\n            : mapVNode(M, x);\n\n    return index;\n\n}());\n//# sourceMappingURL=hyperappmap.js.map\n"]}