{"version":3,"sources":["dist/hyperappmap.js"],"names":["hyperappmap","isFunc","x","isAction","action","Array","isArray","deepMap","map","getResult","state","payload","makeActionMap","extract","merge","memoizedMap","actionFn","mappedAction","memo","get","data","subResult","fullResult","mapEffects","actualMap","slice","rawMap","set","Map","actionStack","mapObj","obj","Object","entries","k","v","reduce","o","effects","fn","opt","mapVNode","vnode","props","children","child"],"mappings":"AAAA,IAAIA,YAAe,WAYf,MAAMC,EAASC,GAAkB,mBAANA,EAErBC,EAAWC,GACbH,EAAOG,IAAYC,MAAMC,QAAQF,IAAWD,EAASC,EAAO,IAE1DG,EAAU,CAACC,EAAKJ,IAClBH,EAAOG,GAAUI,EAAIJ,GAAU,CAACG,EAAQC,EAAKJ,EAAO,IAAKA,EAAO,IAE9DK,EAAY,CAACL,EAAQM,EAAOC,IAC9BV,EAAOG,GACDK,EAAUL,EAAOM,EAAOC,GAAUD,GACjCL,MAAMC,QAAQF,GAEfD,EAASC,GACTK,EACIL,EAAO,GACPM,EACAT,EAAOG,EAAO,IAAMA,EAAO,GAAGO,GAAWP,EAAO,IAEpDA,EAPA,CAACA,GASLQ,EAAgB,CAACC,EAASC,KAC5B,IAWIC,EAAcC,IACd,IAAIC,EAAeF,EAAYG,KAAKC,IAAIH,GAKxC,OAJKC,IACDA,EAdKD,CAAAA,GAAY,CACrBN,EACAU,EACAC,EAAYZ,EAAUO,EAAUH,EAAQH,GAAQU,GAChDE,EAAab,EAAUK,EAAOJ,EAAOW,EAAU,MAC9C,CACDC,EAAW,MACRC,EAAWC,EAAWH,EAAUI,MAAM,OACtCH,EAAWG,MAAM,IAMDC,CAAOV,GACtBD,EAAYG,KAAKS,IAAIX,EAAUC,IAE5BA,GAEXF,EAAYG,KAAO,IAAIU,IACvB,IAAIJ,EAAYK,GAAetB,EAAQQ,EAAac,GACpD,OAAOL,GAGLM,EAAS,CAACtB,EAAKuB,IACjBC,OAAOC,QAAQF,GACVvB,IAAI,EAAE0B,EAAGC,KAAO,CAACD,EAAG/B,EAASgC,GAAK3B,EAAI2B,GAAKA,IAC3CC,OAAO,CAACC,GAAIH,EAAGC,MAASE,EAAEH,GAAKC,EAAIE,GAAI,IAE1Cd,EAAa,CAACf,EAAK8B,IACrBA,EAAQ9B,IAAI,EAAE+B,EAAIC,KAAS,CAACD,EAAIT,EAAOtB,EAAKgC,KAE1CC,EAAW,CAACjC,EAAKkC,IACnBA,EAAMC,MACA,IACOD,EACHC,MAAOb,EAAOtB,EAAKkC,EAAMC,OACzBC,SAAUF,EAAME,SAASpC,IAAIqC,GAASJ,EAASjC,EAAKqC,KAExDH,EASV,MAPY,CAAC7B,EAASC,EAAON,EAAMI,EAAcC,EAASC,KAAWZ,GACjED,EAAOC,GACDM,EAAIN,GACJG,MAAMC,QAAQJ,GACdqB,EAAWf,EAAKN,GAChBuC,EAASjC,EAAKN,GAhFV","sourcesContent":["var hyperappmap = (function () {\n    /*\n\n    makeActionMap = (extract, merge) -> action Map\n\n    put any Action in it, and it will return the corresponding action\n    it will first dig into a stack of payload filters to apply the transform\n    to the actual function. If the actual function is in memo, it will return\n    the memoized transform. Otherwise it will return a new transform of the action\n    and memoize the transform. And part of that means using the\n\n    */\n    const isFunc = x => typeof x === 'function';\n\n    const isAction = action =>\n        isFunc(action) || (Array.isArray(action) && isAction(action[0]));\n\n    const deepMap = (map, action) =>\n        isFunc(action) ? map(action) : [deepMap(map, action[0]), action[1]];\n\n    const getResult = (action, state, payload) =>\n        isFunc(action)\n            ? getResult(action(state, payload), state)\n            : !Array.isArray(action)\n            ? [action]\n            : isAction(action)\n            ? getResult(\n                  action[0],\n                  state,\n                  isFunc(action[1]) ? action[1](payload) : action[1]\n              )\n            : action;\n\n    const makeActionMap = (extract, merge) => {\n        let rawMap = actionFn => (\n            state,\n            data,\n            subResult = getResult(actionFn, extract(state), data),\n            fullResult = getResult(merge, state, subResult[0])\n        ) => [\n            fullResult[0],\n            ...mapEffects(actualMap, subResult.slice(1)),\n            ...fullResult.slice(1),\n        ];\n\n        let memoizedMap = actionFn => {\n            let mappedAction = memoizedMap.memo.get(actionFn);\n            if (!mappedAction) {\n                mappedAction = rawMap(actionFn);\n                memoizedMap.memo.set(actionFn, mappedAction);\n            }\n            return mappedAction\n        };\n        memoizedMap.memo = new Map();\n        let actualMap = actionStack => deepMap(memoizedMap, actionStack);\n        return actualMap\n    };\n\n    const mapObj = (map, obj) =>\n        Object.entries(obj)\n            .map(([k, v]) => [k, isAction(v) ? map(v) : v])\n            .reduce((o, [k, v]) => ((o[k] = v), o), {});\n\n    const mapEffects = (map, effects) =>\n        effects.map(([fn, opt]) => [fn, mapObj(map, opt)]);\n\n    const mapVNode = (map, vnode) =>\n        vnode.props\n            ? {\n                  ...vnode,\n                  props: mapObj(map, vnode.props),\n                  children: vnode.children.map(child => mapVNode(map, child)),\n              }\n            : vnode;\n\n    var index = (extract, merge, map = makeActionMap(extract, merge)) => x =>\n        isFunc(x)\n            ? map(x)\n            : Array.isArray(x)\n            ? mapEffects(map, x)\n            : mapVNode(map, x);\n\n    return index;\n\n}());\n//# sourceMappingURL=hyperappmap.js.map\n"]}